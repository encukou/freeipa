# Copyright (C) 2016  Red Hat
# see file 'COPYING' for use and warranty information
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
import errno
import glob
import os
import sys
from distutils import log
from distutils.core import Command
from distutils.errors import DistutilsOptionError
from setuptools.command.build_py import build_py as setuptools_build_py


class build_py(setuptools_build_py):
    """Exclude NAME.install subpackage from wheels
    """
    def initialize_options(self):
        setuptools_build_py.initialize_options(self)
        self.skip_modules = ()

    def finalize_options(self):
        setuptools_build_py.finalize_options(self)
        omit = os.environ.get('IPA_OMIT_INSTALL', '0')
        if omit == '1':
            distname = self.distribution.metadata.name
            self.skip_modules = (
                # *.install.* subpackages
                '{}.install'.format(distname),
                # platform override module
                'ipaplatform.override',
            )
            log.warn("bdist_wheel: Ignore package: %s",
                     ', '.join(self.skip_modules))

    def build_module(self, module, module_file, package):
        if isinstance(package, str):
            package = package.split('.')
        name = '.'.join(list(package) + [module])
        if self.skip_modules and name.startswith(self.skip_modules):
            # remove file in case it has been copied to build/lib before
            outfile = self.get_module_outfile(self.build_lib, package, module)
            try:
                os.unlink(outfile)
            except OSError:
                pass
        else:
            return setuptools_build_py.build_module(self, module,
                                                    module_file, package)


class copy_base(Command):
    user_options = [
        ('target-dir=', None, "target directory to copy to"),
    ]

    def initialize_options(self):
        # Command.initialize_options(self)
        self.target_dir = None

    def finalize_options(self):
        # Command.finalize_options(self)
        if self.target_dir is None:
            raise DistutilsOptionError('copy_dist requires --target-dir')
        if not os.path.isdir(self.target_dir):
            raise DistutilsOptionError(
                'target-dir={} does not exist'.format(self.target_dir)
            )

    def _process_directory(self, src_dir, dest_dir):
        pass

    def _process_file(self, src_file, dest_file):
        pass

    def _post_process(self):
        pass

    def run(self):
        build_py = self.get_finalized_command('build_py')
        build_scripts = self.get_finalized_command('build_scripts')

        # pylint: disable=unused-variable
        for package, src_dir, build_dir, filenames in build_py.data_files:
            log.info("Processing package %s", package)
            abs_src_dir = os.path.abspath(src_dir)
            abs_dest_dir = os.path.abspath(
                os.path.join(self.target_dir, src_dir)
            )
            if abs_src_dir == abs_dest_dir:
                # same dir, nothing to do
                log.info("Nothing to do %s == %s", abs_src_dir, abs_dest_dir)
                continue

            self._process_directory(abs_src_dir, abs_dest_dir)

            pys = glob.glob(os.path.join(abs_src_dir, '*.py'))
            for py in pys:
                dest_py = os.path.join(abs_dest_dir, os.path.basename(py))
                self._process_file(py, dest_py)

            for datafile in filenames:
                abs_src_datafile = os.path.join(abs_src_dir, datafile)
                abs_dest_datafile = os.path.join(abs_dest_dir, datafile)
                self._process_directory(
                    os.path.dirname(abs_src_datafile),
                    os.path.dirname(abs_dest_datafile)
                )
                self._process_file(abs_src_datafile, abs_dest_datafile)

            log.info("Done %s", package)

        scripts = build_scripts.get_source_files()
        if scripts:
            for script in scripts:
                src_script = os.path.abspath(script)
                dest_script = os.path.abspath(
                    os.path.join(self.target_dir, script)
                )
                if src_script != dest_script:
                    self._process_file(src_script, dest_script)

        self._post_process()


class copy_dist(copy_base):
    def _process_directory(self, src_dir, dest_dir):
        if not os.path.isdir(dest_dir):
            log.debug("makedirs %s", dest_dir)
            self.mkpath(dest_dir)

    def _process_file(self, src_file, dest_file):
        log.debug("copy %s to %s", src_file, dest_file)
        self.copy_file(src_file, dest_file)


class clean_copy_dist(copy_base):
    def _process_directory(self, src_dir, dest_dir):
        pass

    def _process_file(self, src_file, dest_file):
        log.debug("Deleting %s", dest_file)
        try:
            os.unlink(dest_file)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise

    def _post_process(self):
        # Walk bottom up to remove all files
        target_dir = os.path.abspath(self.target_dir)
        # pylint: disable=unused-variable
        for dirpath, _, _ in os.walk(target_dir, topdown=False):
            if dirpath == target_dir:
                continue
            log.debug("rmdir %s", dirpath)
            try:
                os.rmdir(dirpath)
            except OSError as e:
                if e.errno not in (errno.ENOTEMPTY, errno.ENOENT):
                    raise


import setuptools

VERSION = '@VERSION@'

SETUPTOOLS_VERSION = tuple(int(v) for v in setuptools.__version__.split("."))

# backwards compatibility with setuptools 0.9.8, split off +gitHASH suffix
# PEP 440 was introduced in setuptools 8.
if SETUPTOOLS_VERSION < (8, 0, 0):
    VERSION = VERSION.split('+')[0]


PACKAGE_VERSION = {
    'cryptography': 'cryptography >= 1.6',
    'custodia': 'custodia >= 0.3.1',
    'dnspython': 'dnspython >= 1.15',
    'gssapi': 'gssapi >= 1.2.0',
    'ipaclient': 'ipaclient == {}'.format(VERSION),
    'ipalib': 'ipalib == {}'.format(VERSION),
    'ipaplatform': 'ipaplatform == {}'.format(VERSION),
    'ipapython': 'ipapython == {}'.format(VERSION),
    'ipaserver': 'ipaserver == {}'.format(VERSION),
    'jwcrypto': 'jwcrpyto >= 0.4.2',
    'kdcproxy': 'kdcproxy >= 0.3',
    'netifaces': 'netifaces >= 0.10.4',
    'python-ldap': 'python-ldap >= 3.0.0b1',  # install --pre
    'python-yubico': 'python-yubico >= 1.2.3',
    'qrcode': 'qrcode >= 5.0',
}


common_args = dict(
    version=VERSION,
    license="GPLv3",
    author="FreeIPA Developers",
    author_email="freeipa-devel@redhat.com",
    maintainer="FreeIPA Developers",
    maintainer_email="freeipa-devel@redhat.com",
    url="http://www.freeipa.org/",
    download_url="http://www.freeipa.org/page/Downloads",
    platforms=["Linux", "Solaris", "Unix"],
    python_requires=">=2.7.5,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*",
    classifiers=[
        "Development Status :: 5 - Production/Stable",
        "Intended Audience :: System Administrators",
        ("License :: OSI Approved :: "
         "GNU General Public License v3 (GPLv3)"),
        "Programming Language :: C",
        "Programming Language :: Python :: 2",
        "Programming Language :: Python :: 2.7",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.5",
        "Programming Language :: Python :: 3.6",
        "Programming Language :: Python :: Implementation :: CPython",
        "Operating System :: POSIX",
        "Operating System :: POSIX :: Linux",
        "Operating System :: Unix",
        "Topic :: Internet :: Name Service (DNS)",
        "Topic :: Security",
        ("Topic :: System :: Systems Administration :: "
         "Authentication/Directory :: LDAP"),
    ],
)

local_path = os.path.dirname(os.path.abspath(sys.argv[0]))
old_path = os.path.abspath(os.getcwd())


def ipasetup(name, doc, **kwargs):
    doclines = doc.split("\n")

    install_requires = list(kwargs.pop('install_requires', []))
    for i, entry in enumerate(install_requires):
        install_requires[i] = PACKAGE_VERSION.get(entry, entry)

    setup_kwargs = common_args.copy()
    setup_kwargs.update(
        name=name,
        description=doclines[0],
        long_description="\n".join(doclines[:2]),
        install_requires=install_requires,
        **kwargs
    )
    # exclude setup helpers from getting installed
    epd = setup_kwargs.setdefault('exclude_package_data', {})
    epd.setdefault('', []).extend(['*/setup.py', '*/ipasetup.py'])
    # exclude NAME.install from wheels
    cmdclass = setup_kwargs.setdefault('cmdclass', {})
    cmdclass['build_py'] = build_py
    cmdclass['copy_dist'] = copy_dist
    cmdclass['clean_copy_dist'] = clean_copy_dist

    # Env markers like ":python_version<'3'" are not supported by
    # setuptools < 18.0.
    if 'extras_require' in setup_kwargs and SETUPTOOLS_VERSION < (18, 0, 0):
        for k in list(setup_kwargs['extras_require']):
            if not k.startswith(':'):
                continue
            values = setup_kwargs['extras_require'].pop(k)
            req = setup_kwargs.setdefault('install_requires', [])
            if k == ":python_version<'3'":
                if sys.version_info.major == 2:
                    req.extend(values)
            elif k == ":python_version>='3'":
                if sys.version_info.major >= 3:
                    req.extend(values)
            else:
                raise ValueError(k, values)

    # BEFORE importing distutils, remove MANIFEST. distutils doesn't
    # properly update it when the contents of directories change.
    if os.path.isfile('MANIFEST'):
        os.unlink('MANIFEST')
    from setuptools import setup
    return setup(**setup_kwargs)
